using Microsoft.VisualStudio.TestPlatform;

namespace WeatherService.Testing.NUnit.Unit.Core.Specifications;

/// <summary>
/// We want our tests to run as fast as possible
/// More info https://www.meziantou.net/performance-benefits-of-sealed-class.htm.
/// </summary>
/// <typeparam name="TAssemblyMarker">The marker of the assembly that contains the test classes to validate.</typeparam>
[TestFixture]
public abstract class TestClassesTestSpecification<TAssemblyMarker>
{
    private static IEnumerable<Type> AssemblyTypes()
    {
        var testSDKAutoGeneratedCodeAttribute = typeof(TestSDKAutoGeneratedCode);

        return typeof(TAssemblyMarker).Assembly
            .GetTypes()
            .Where(t => Attribute.GetCustomAttribute(t, testSDKAutoGeneratedCodeAttribute) is null)
            .ToList();
    }

    private static IEnumerable<TestCaseData> SetUpFixtures()
    {
        var setUpFixtureAttribute = typeof(SetUpFixtureAttribute);

        return AssemblyTypes()
            .Where(t => Attribute.GetCustomAttribute(t, setUpFixtureAttribute) is not null)
            .Select(t => new TestCaseData(t).SetName(t.FullName))
            .ToList();
    }

    protected static IEnumerable<TestCaseData> TestClasses()
    {
        var setUpFixtureAttribute = typeof(SetUpFixtureAttribute);

        return AssemblyTypes()
            .Where(t => Attribute.GetCustomAttribute(t, setUpFixtureAttribute) is null)
            .Select(t => new TestCaseData(t).SetName(t.FullName))
            .ToList();
    }

    [TestCaseSource(nameof(SetUpFixtures))]
    public void SetupFixtures_should_be_public(Type type)
    {
        type.IsPublic.Should().BeTrue(because: $"{type} should be public");
    }

    [TestCaseSource(nameof(TestClasses))]
    public virtual void All_test_classes_should_be_internal(Type type)
    {
        type.IsPublic.Should().BeFalse(because: $"{type} should be internal for performance");
    }

    [TestCaseSource(nameof(TestClasses))]
    public void All_test_classes_should_be_abstract_or_sealed_or_have_inheritor(Type type)
    {
        (type.IsAbstract || type.IsSealed || HasInheritors(type)).Should().BeTrue(because: $"{type} should be abstract or sealed");
    }

    private static bool HasInheritors(Type type)
    {
        return TestClasses().Select(x => (Type)x.Arguments[0]!).Any(t => IsInheritor(t, type));
    }

    private static bool IsInheritor(Type type, Type targetType)
    {
        if (type.IsGenericType && targetType.IsGenericTypeDefinition)
        {
            return type.GetGenericTypeDefinition() == targetType;
        }
        return targetType.IsAssignableFrom(type) && type != targetType;
    }
}